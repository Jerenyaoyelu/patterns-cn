# 孤岛架构

孤岛架构鼓励在 SSR 渲染的网页中构建小而功能专注的交互体验

总结：孤岛架构鼓励在 SSR 渲染的网页中构建小而功能专注的交互体验。孤岛的输出是渐进式的加强 HTML，尤其关于这种加强是如何发生的更加有明确性。相比控制某一应用的整个页面渲染，有多个入口点。在允许页面的其余部分为静态页面的情况下，这些可交互岛的脚本可以被单独传输和水合。

JS 的加载和处理执行会影响性能。然而，即使是在静态内容主导的页面也常常需要一定程度的可交互性和 JS。我们已经讨论了帮助你构建应用的静态渲染的变体以便能找出以下两点之间平衡：

1. 对比 CSR 客户端渲染的可交互性
2. 和 SSR 相比的 SEO 友好性

SSR 的核心原则是 HTML 在服务器渲染后和再水合必要的 JS 脚本一起被传输到客户端。再水合是在服务端渲染后重新在客户端生成 UI 组件的状态。自从再水合会产生一定损耗，每一个 SSR 渲染的变体都试着去优化再水合过程。这主要通过对关键组件的部分水合或者在渲染时对组件流化实现。然而上述技术最终传输的网络部分 JS 还是一样的。

孤岛架构一词被 Katie Sylor-Miller 和 Jason Miller 发扬光大，用来描述一种旨在通过可以在其他静态 HTML 之上被独立传输的可交互性岛来减少 JS 传输量。孤岛是一种基于组件的架构用静态和动态孤岛来表示整个页面的分隔的视图。页面的静态区域是纯不可交互的 HTML，并不需要水合。动态区域则是渲染之后 HTML 和再水合脚本的组合。

![](../../assets/islands_architecture_1.png)

让我们更加详细的来讨论下目前基于不同选项实现的孤岛架构。

## 动态组件的孤岛

大多数网页是动态和静态内容的结合体。通常，一个网页是有静态内容和零星的可被隔离的可交互区域组成。例如：

1. 博客帖子、新闻文章以及机构主页包含了图文和可交互部件如嵌入的社交媒体和聊天。
2. 电商网站的商品页面包含了静态商品描述和跳转到应用的其他页面的链接。网页其他区域还有可交互组件如走马灯图片和搜索。
3. 一个典型的银行账号详情网页包含了带了一定程度可互动的筛选功能的一连串的静态交易记录。

静态内容是无状态的，不需要触发事件，也不需要在渲染后再水合。页面渲染后，动态内容（按钮、筛选、搜索栏）必须重新连接到对应的事件。DOM 必须在客户端（虚拟 DOM）上重新被生成。这些再生成、再水合和事件处理函数组成了要被传输到客户端的 JS 脚本。

孤岛架构有助于呈现所有静态内容的 SSR 渲染页面。然而，这个时候，渲染的 HTML 会包含动态就内容的占位符。动态内容占位符包含了独立的组件部件。每一个小部件类似于一个小应用，组成了服务端渲染的输出和用来在客户端水合的 JS 脚本。

在渐进式水合的过程中，网页水合的架构是自顶而下的。网页控制了单个组件的调度和水合。孤岛架构中的每个组件有其对应的异步执行且和网页中其他脚本相互独立的水合脚本。一个组件的性能问题不会影响其他组件。

![](../../assets/islands_architecture_2.png)

## 实现孤岛

孤岛架构从不同来源借鉴的理念，目标以最优方式去组合他们。基于模版的静态网页生成器如[Jekyll](https://jekyllrb.com/)和[Hugo](https://gohugo.io/)支持将静态组件渲染到网页上。大多数现代 JS 框架也支持允许使用一套代码同时在服务端和客户端渲染元素的同构渲染（isomorphic rendering）。

Shopify 的工程师[Jason Miller](https://github.com/developit)关于孤岛架构的博文解释了使用 requestIdleCallback()来实现一个用于水合组件的调度方式。静态同构渲染和组件级别的部分水合调度能够内嵌到一个框架中来支持孤岛架构。因此，这个架构需要

1. 支持在服务端 0KB JS 网页的静态渲染
2. 支持在静态内容中通过占位符嵌入独立的动态组件。每一个动态组件包含其对应脚本，并且只要主线程一空闲就能用 requestIdleCallback()来水合自身。
3. 允许在客户端水合对服务端上的组件进行同构渲染以识别两端的同一组件。

你可以使用下面讨论的现成选项之一来实现这一点。

## 框架

> 待翻译

## 实现示例

> 待翻译

## 优劣势

> 待翻译
